logging.pattern.console=%d{HH:mm:ss.SSS} %-12.12thread %-20.20logger{0} %message%n

# @Transactional debugging
#logging.level.org.springframework.orm.jpa.JpaTransactionManager=TRACE

# Hibernate Logging
#logging.level.org.hibernate.SQL=DEBUG

# original
#spring.datasource.url = jdbc:h2:tcp://localhost:9092/~/test
#spring.datasource.driver-class-name= org.h2.Driver
# p6spy JDBC Driver logging proxy
# a) adaugi dependinta p6spy:p6spy
# b) adaugi spy.properties !
# c) modifici URL si driver-class-name
spring.datasource.url = jdbc:p6spy:h2:tcp://localhost:9092/~/test
spring.datasource.driver-class-name= com.p6spy.engine.spy.P6SpyDriver

spring.datasource.username=sa
spring.datasource.password=sa

# DOAR PT TEST: JPA, te rog sa-mi creezi schema la startup pe baza de entitatilor din aplicatie
# POATE CAUZA LazyInitializationException
spring.jpa.hibernate.ddl-auto=create

# #2 motiv pt write behind: amanand inseturile, JPA poate face batching pre-commit automat, marind viteza unui batch import de zeci de ori
#spring.jpa.properties.hibernate.jdbc.batch_size = 100

# spui lui Spring sa NU MAI tina connex blocata pana la finalul req http
#spring.jpa.open-in-view=false

spring.h2.console.enabled=true
#> http://localhost:8080/h2-console
# driver : org.h2.Driver
# url : jdbc:h2:tcp://localhost:9092/~/test
# user : sa
# password : sa